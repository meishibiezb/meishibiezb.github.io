import{_ as e,c as r,o as a,ag as o}from"./chunks/framework.GIpVouxN.js";const g=JSON.parse('{"title":"核心素养","description":"","frontmatter":{"title":"核心素养"},"headers":[],"relativePath":"essential-competences.md","filePath":"essential-competences.md","lastUpdated":1757136677000}'),s={name:"essential-competences.md"};function n(i,t,c,l,b,p){return a(),r("div",null,[...t[0]||(t[0]=[o('<h1 id="当我们学习计算机时-我们在学习什么" tabindex="-1">当我们学习计算机时，我们在学习什么？ <a class="header-anchor" href="#当我们学习计算机时-我们在学习什么" aria-label="Permalink to &quot;当我们学习计算机时，我们在学习什么？&quot;">​</a></h1><p>    计算机专业十分重视实践。 仅仅是课堂上听讲，课后完成作业，很难学好计算机。 因为总体来讲，我们的学校能够给你提供的资源十分有限。 而另一方面，现在企业的用人要求越来越高，劳动者的上岗压力也越来越大。 仅靠学校提供的教学资源难以有效衔接企业的用人标准。 更何况，学校的课程可能并不能教你太多东西，至少跟你能在网上学到的东西相比是很少的。 另外，我们可以简要地概括计算机专业的学习方式。 即<code>遇到问题-&gt;学习前人思路-&gt;提出解决方案-&gt;实现具体功能-&gt;评估效果-&gt;提出新的问题</code>。<br>     这种在实践中学习的方法十分有效，也能锻炼我们各方面的能力。 以上所述问题，为我们计算机专业的学生提出了要求。 即要培养收集信息的能力和解决问题的能力。 这两种能力可以说是计算机专业的核心素养。 可以说，学习计算机，就是在学这两种能力。</p><hr><h1 id="收集信息的能力" tabindex="-1">收集信息的能力 <a class="header-anchor" href="#收集信息的能力" aria-label="Permalink to &quot;收集信息的能力&quot;">​</a></h1><p>    收集信息这项能力，不仅对于计算机专业的学生，而且对于各行各业的人来说，都是十分重要的。 更进一步地说，对于现代社会的人来说都很重要。 因为我们生活在一个信息爆炸的时代，能够把握住信息，你就能取得优势。<br>     在上一部分，我们讨论过，当下企业的用人标准在提高。 那么，到底提高到什么程度呢？ 我们作为学生应该学习哪方面知识才能找到工作呢？ 这些问题，课堂上很难找到答案。 这个问题本身就很难回答，网上即使能找到其他人给出的意见，也不一定适合我们，或者说已经失去时效性，或者说观点不够全面。 要回答这个问题，只有靠我们自己。 我们应该从各个渠道收集信息，结合自身实际体验进行评估。 同样，我们应该如何给自己补充教育资源？ 如何找到好的资源？ 如何避免被坑？ 这也是收集信息的一个目的，也是一门值得深究的学问。<br>     并且，我们不仅要收集信息，而且要广泛地收集信息。 现在有个词语叫“信息茧房”。 我们每个人的观点本身就不可避免地带有片面之处，而信息茧房又更加加剧了这种片面。 如果你发现自己每天看到的都是自己想看的东西，自己已经很久没有反思过了，那么说明情况可能比较危险了。 有时候我们有必要跳出自己的“信息舒适圈”，去尝试一些新东西，接触一些新的观点。 这就是为什么说我们要“广泛”地收集信息。 信息渠道的多样性也是需要考虑的。<br>     不过，说了那么多，收集信息的能力具体是什么样的？<br>     第一点是<strong>对信息的敏感性</strong>。 你应该能够有效地分别出什么什么是对你有用的信息，并且能够分析其有用之处，而且能够妥善地把它归纳到你的知识体系里。 你在生活中应该处处留心接触到的信息。 有时候，获取信息并不在于你能不能接触到它们，而在于你能不能注意到它们，能不能认识到它们的重要性。 你可能觉得我说得有点像是当间谍。 那我我换个说法吧，说一个比较具体的的做法。 当你看到一个新名词时，留意它，最好知道它是在说什么。 如果你对它很好奇，也可以干脆去搞懂它。 不过这也并不是要求你要搞懂所有东西，只是说，当未来要用到这个信息的时候，你最好能记起来有这么一回事。 如果你还没有这个习惯的话，可以试着养成这个习惯。 我认为，这在未来很可能会帮到你。<br>     第二点是<strong>积累的资源</strong>。 拥有大量的信息和信息来源渠道并不是一朝一夕就能完成的事情。 拥有相对优越的信息储备和来源要靠长期的积累。 不过正如某个我不知道名字的人所说的那样，</p><blockquote><p>种一棵树最好的时机是十年前，其次是现在</p></blockquote><p>如果你发现自己处于一个耳目闭塞的境地，那就从现在开始积累吧。 下面我来解释一下具体什么叫做“信息”和“信息来源渠道”。 所谓信息，你学到的知识当然算在其中。 此外，市场的行情也可以算作是信息。 社会经济的运行状况、人民的生活方式等等，这些都值得我们注意。 至于信息来源渠道，其种类也很多样。 我们常说的“人脉”，可以算作一样。 当你遇到问题的时候，你可能会向你的老师、同学、家长或者朋友求助。 如果你认识的人比较多，那你能够求助的对象就更多，得到帮助的概率也越大。 如果你不需要帮助，仅仅只是闲聊，或者给别人提供帮助，也可以让你得到有用的信息。 所以说，<strong>社交是很重要的</strong>。 虽然说这句话可能和“如何学习计算机”这个主题不太相关，但是我还是很想说。 因为篇文章是面向大学生的，而大学生可能会需要这句话。 除了人脉之外，上网也是获取信息的重要渠道。 会不会上网，是评判你收集信息能力的重要标准。 有些读者可能会疑惑，现在互联网已经普及了，上网应该不成问题了才对。 事实上，上网的能力也有高低之分。 这点有很多可谈之处，以后我可能会专门写文章来介绍，但在此就不多赘述了。<br>     第三点是<strong>辨别信息和做出判断的能力</strong>。 信息收集得再多，若是不会筛选、不会辨别，那也不过是一堆杂乱无章的噪音。 我们生活在一个信息过载的时代，每天接触到的信息量远超我们能够处理的范围。 这其中，有真有假、有深有浅、有急有缓，甚至有些信息看似有用实则误导人。 如果你不懂得如何辨别，就很容易被错误的信息带偏，轻则浪费时间，重则影响判断和决策。 这一点，在技术领域尤其明显——一个过时的解决方案、一个未被验证的“黑科技”、一个看似高效实则漏洞百出的代码示例，都可能让你在错误的道路上越走越远。<br>     那么，具体该怎么辨别信息？ 首先，你要学会质疑。 不是所有写进博客的技术方案都是最优解，不是所有 GitHub 上的项目都值得信赖，也不是所有论坛里的回答都准确无误。 你要习惯性地问：这个信息的来源是什么？发布者是谁？有没有利益相关？它是否经过实践验证？有没有其他人提出不同意见？ 其次，你要学会交叉验证。 不要只依赖单一信息源做出判断。多找几个渠道对比一下，看看不同的人、不同的社区、不同的平台是怎么说的。 如果某个说法在多个可信的地方都被重复提到，那它大概率的可靠性就更高。 再者，你要有自己的判断框架。 这需要你逐渐建立起自己的知识体系和价值观——知道什么是对的、什么是错的，什么适合当前场景、什么可能只是“听起来很美好”。 这个过程没有捷径，只能靠你不断实践、不断反思、不断积累经验。<br>     最后，做出判断之后，还要有勇气去执行，也要有灵活性去调整。 信息是动态的，技术是发展的，你昨天的判断可能今天就已经不适用。 所以，辨别信息不是一个一次性的动作，而是一个持续的过程。 你要保持开放的心态，随时准备修正自己的认知，但也不能轻易被别人的观点带跑。 这种能力，说白了，就是一种“清醒的自信”——既知道该相信什么，也知道为什么要相信。<br>     说到底，收集信息不是目的，用好信息才是。 而用好信息的前提，就是你得先学会辨别它、判断它。 这一点，可能比单纯地“知道得多”要重要得多。</p><hr><h1 id="解决问题的能力" tabindex="-1">解决问题的能力 <a class="header-anchor" href="#解决问题的能力" aria-label="Permalink to &quot;解决问题的能力&quot;">​</a></h1><p>    现在AI工具已经很普及了。 Vibe Coding也成为了程序员的必备技能。 现在的AI工具，功能确实十分强大。 这给我们提供了许多便利。 不过换个角度想一想，这也使得一些只能胜任简单的工作的程序员的竞争力下降。 我估计大家将来就算不想成为科学家，大概也会想成为工程师吧。 这两种职业无论哪个，都要求具备良好的创新能力。 我们学习计算机知识、运用计算机技术的时候，仅仅是复刻前人的解决方案，是远远不够的。 要体现出自己的价值，必须要拿出自己的新东西。<br>     我们在学习或者工作中，常常会遇到各种各样的技术问题。 这些问题有些是前人已经解决过，能够在网上找到成熟的解决方案的。 然而也有很多问题，它们的答案还是空缺的，需要我们填补上。 可以说，解决这类问题，才是当下人类程序员的价值所在。 因为那些已经被人重复过无数次的操作，交给AI工具就可以了。 可以预见的是，在未来的就业市场上，那些没有独立解决问题能力的竞争者，被淘汰是必然的。<br>     那么，这个“解决问题的能力”具体包括哪些方面呢？ 那么，这个“解决问题的能力”具体包括哪些方面呢？<br>     第一点是<strong>问题分析与拆解能力</strong>。 面对一个复杂问题时，首先要做的不是急着写代码，而是静下心来分析。 这个问题到底属于什么类型？可以拆分成哪些子问题？每个子问题的优先级如何？ 就像修一栋大楼，你得先画图纸、打地基，而不是直接开始砌墙。 学会用思维导图、流程图等工具来梳理问题结构，往往能让解决过程事半功倍。<br>     第二点是<strong>创新与设计思维</strong>。 在AI工具能完成基础编码的今天，程序员的独特价值在于创造性解决问题。 这意味着你不能总是套用现成方案，而要能够根据具体场景设计出最合适的解决方案。 比如，同样是实现一个功能，你可以思考：有没有更优雅的实现方式？能不能更好地平衡性能与可维护性？ 这种设计思维，是区分普通程序员和优秀工程师的关键。<br>     第三点是<strong>系统化实现能力</strong>。 有了好的设计方案后，如何将它落地成可靠的代码？ 这需要你具备扎实的编程基础、熟悉开发工具链、掌握测试和调试技巧。 更重要的是，你要有工程化的思维——写的代码不仅要能跑，还要易读、易维护、易扩展。 这种能力不是一朝一夕能练成的，需要在真实项目中反复磨练。<br>     第四点是<strong>评估与迭代优化能力</strong>。 解决问题很少能一步到位，更多时候需要不断调整优化。 这就要求你能够客观评估解决方案的效果：是否达到了预期？有没有潜在问题？还有没有改进空间？ 同时，要敢于否定自己的方案，愿意重构代码，追求更好的实现。 这种持续改进的意识，是保持技术竞争力的重要保障。<br>     我建议大家在学习过程中如果有自己的想法，可以大胆去做。 不要害怕遇到新问题，不要怕麻烦和困难。 毕竟计算机是实践的世界。 每个人都有机会把自己的想法变成现实。 这正是学习计算机的乐趣所在。 克服重重困难做出一个复杂和有创新的项目，比跟着教程做一些千篇一律的项目，能够给你带来更多收获。</p><hr><h1 id="怎么提问" tabindex="-1">怎么提问 <a class="header-anchor" href="#怎么提问" aria-label="Permalink to &quot;怎么提问&quot;">​</a></h1><p>    我遇到问题之后一般的习惯是，先上网搜一搜有什么解决办法，打开几个网页，看看有没有相关内容，猜一下到底发生了什么。 然后鼓捣了半天，可能就把问题解决了。 当然也有可能没有解决问题。 在这种情况下，我有可能会去提问，也有可能干脆就不管这个问题了。 因为我是一个非必要不社交的人，与别人交流对我来说比较困难，一般情况下比自己解决一个问题要困难。 多亏了这个习惯，我从小到大这样自己解决了不少问题，也有了点解决问题的能力。 其实，一般来讲，不提问也没什么大碍。 如果你也和我一样懒于社交，那么你可以松一口气了。<br>     但那只是大多数情况，同时也存在着少部分情况，在这种情况下提问是必要的。 并且我相信肯定也有很多人的习惯与我相反，爱好提问和与人交流。 应当承认的是，提问是一个好习惯，有很多益处。 并且，在网上的提问更多了一层意义，你在网上遗留下来的提问记录很可能帮助到后来遇到相同问题的人（我本人也常常受益于此）。<br>     不过，在学习计算机的过程中，你最好了解一下怎么提问题。 你在学习计算机的过程中会遇到各种各样的社区，你也很可能需要利用到社区资源。 要注意的是，社区当然有社区的一些规则，否则社区也就难以维持良好的秩序。 我们如果想要充分利用社区的资源，自然也要尊重这种秩序。 所以说，我们应该了解一下“如何提问”这个问题的解决办法。<br>     <a href="https://lug.ustc.edu.cn/wiki/doc/smart-questions/" target="_blank" rel="noreferrer">《提问的智慧》</a>这篇文章中已经完备地论述了这个问题。我在此就不多赘述了。</p><div class="warning custom-block"><p class="custom-block-title">我的建议是所有人都要读一读这篇文章</p><p>《提问的智慧》这篇文章十分经典，并且在计算机技术社区中广为流传。 可以说即使你没有在这里遇见它，你也会在别的地方遇见它的。 这篇文章的其中一个意义，我认为，是帮助我们避免麻烦。 所以说，与其在陷入某种麻烦才去阅读它，不如现在就去读一读，避免这些麻烦的发生。</p></div>',14)])])}const h=e(s,[["render",n]]);export{g as __pageData,h as default};
